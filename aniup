#!/usr/bin/env bash
# Quick and dirty script to increment the watched count for an episode.
#
# Dependencies: curl, jq, fzf
#
# Optional environment variables:
#   $KITSU_USERNAME: The default username to check. Can be overriden with $1.

checkdep() {
  which "$1" &>/dev/null || echo " $1"
}

missing="$(checkdep curl)$(checkdep jq)$(checkdep fzf)"
if [ "$missing" ]; then
  echo "The following dependencies are missing:$missing"
  exit 1
fi

usage() {
  echo "Usage: $(basename "$0") [kitsu.io username]"
  exit 1
}

# Complain if too many args
[ "$#" -gt 1 ] && usage
[[ "$1" == -* ]] && usage

# If arg provided, use it
[ "$1" ] && KITSU_USERNAME="$1"

# Check for required variables
if [ -z "$KITSU_USERNAME" ]; then
  echo 'Required: $KITSU_USERNAME'
  exit 1
fi

maybe_exit() {
  if [ -z "$1" ]; then
    echo "$2"
    exit "${3:-1}"
  fi
}

base="https://kitsu.io/api"
api="$base/edge"
oauth="$base/oauth"

uid_cache=~/.cache/kitsu/usernames/"$KITSU_USERNAME"
token_dir=~/.local/tokens/kitsu/password
mkdir -p "$token_dir"

# Try to get existing token
token_file="$token_dir/$KITSU_USERNAME"
if [ -f "$token_file" ]; then
  # If not expired, simply use it
  expiry="$(jq -r '.created_at + .expires_in // ""' "$token_file")"
  if [ "${expiry:-0}" -gt "$(date +%s)" ]; then
    token_json="$(< "$token_file")"
  # Otherwise, grab a new one
  else
    refresh_token="$(jq -r '.refresh_token // ""' "$token_file")"
    if [ "$refresh_token" ]; then
      token_json="$(curl -sfgX POST \
        -d "grant_type=refresh_token&refresh_token=$refresh_token" \
        "$oauth/token")"
      [ "$token_json" ] &&
        jq ".refresh_token = $refresh_token" \
        <<< "$token_json" > "$token_file"
    fi
  fi
fi

# If we failed to get it, prompt to authorize
if [ -z "$token_json" ]; then
  [ -z "$KITSU_PASSWORD" ] && read -sp \
    "Enter the password for $KITSU_USERNAME: " KITSU_PASSWORD
  echo

  token_json="$(curl -sfgX POST \
    -d \
  "grant_type=password\
&username=$KITSU_USERNAME\
&password=$KITSU_PASSWORD" \
    "$oauth/token")"
  maybe_exit "$token_json" 'Failed to authenticate.'

  echo "$token_json" > "$token_file"
fi

token="$(jq -r '.access_token' <<< "$token_json")"

# Get user ID
uid="$(< "$uid_cache")"
if [ "$uid" ]; then
  echo "User ID for $KITSU_USERNAME cached."
else
  echo "Fetching user ID for $KITSU_USERNAME..."
  uid="$(curl -sfg \
    "$api/users\
  ?fields[users]=id\
  &filter[name]=$KITSU_USERNAME" |\
    jq -r '.data[0].id')"
  maybe_exit "$uid" 'Failed to get user ID.'
fi

# Fetch entries
echo "Fetching library entries..."
entries="$(curl -sfg \
  "$api/library-entries\
?page[limit]=500\
&include=anime\
&fields[libraryEntries]=progress,anime\
&fields[anime]=canonicalTitle,episodeCount\
&filter[status]=current\
&filter[userId]=$uid" |\
  jq -r '(
    .included |
    map({key: .id,
         value: {title: .attributes.canonicalTitle,
                 eps: .attributes.episodeCount}}) | from_entries
  ) as $index | .data[] | $index[.relationships.anime.data.id] as $entry |
  "\(.id)\t\(.attributes.progress)/\($entry.eps)\t\($entry.title)"')"
maybe_exit "$entries" "No entries found for $KITSU_USERNAME." 0

# Get user selection
selection="$(fzf --with-nth 2.. <<< "$entries")"
[ -z "$selection" ] && exit 0
id="$(cut -f1 <<< "$selection")"
ep_stats="$(cut -f2 <<< "$selection")"
anime="$(cut -f3- <<< "$selection")"
next_ep="$((${ep_stats%%/*} + 1))"

json_patch="$(jq -r \
  '. = {
    access_token: "'"$token"'",
    data: {
      type: "library-entries",
      id: '"$id"',
      attributes: {
        progress: '"$next_ep"'
      }
    }
  }' <<< '{}')"

curl -sfgX PATCH \
  -d "$json_patch" \
  -H 'Content-Type: application/vnd.api+json' \
  "$api/library-entries/$id" &>/dev/null &&
    echo "Updated $anime to episode $next_ep." ||
    echo "Failed to update $anime to episode $next_ep."
